INTTK int
IDENFR global_int
SEMICN ;
CHARTK char
IDENFR global_char
SEMICN ;
INTTK int
IDENFR arr
LBRACK [
INTCON 10
RBRACK ]
SEMICN ;
CHARTK char
IDENFR str
LBRACK [
INTCON 100
RBRACK ]
SEMICN ;
INTTK int
IDENFR add
LPARENT (
INTTK int
IDENFR a
COMMA ,
INTTK int
IDENFR b
RPARENT )
LBRACE {
INTTK int
IDENFR result
SEMICN ;
IFTK if
LPARENT (
IDENFR a
EQL ==
INTCON 0
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR b
EQL ==
INTCON 0
RPARENT )
LBRACE {
IDENFR result
ASSIGN =
INTCON 0
SEMICN ;
RBRACE }
ELSETK else
LBRACE {
IDENFR result
ASSIGN =
IDENFR b
SEMICN ;
RBRACE }
RBRACE }
ELSETK else
LBRACE {
IFTK if
LPARENT (
IDENFR b
EQL ==
INTCON 0
RPARENT )
LBRACE {
IDENFR result
ASSIGN =
IDENFR a
SEMICN ;
RBRACE }
ELSETK else
LBRACE {
IDENFR result
ASSIGN =
IDENFR a
PLUS +
IDENFR b
SEMICN ;
RBRACE }
RBRACE }
RETURNTK return
IDENFR result
SEMICN ;
RBRACE }
INTTK int
IDENFR multiply
LPARENT (
INTTK int
IDENFR a
COMMA ,
INTTK int
IDENFR b
RPARENT )
LBRACE {
INTTK int
IDENFR result
SEMICN ;
IFTK if
LPARENT (
IDENFR a
NEQ !=
INTCON 0
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR b
NEQ !=
INTCON 0
RPARENT )
LBRACE {
IDENFR result
ASSIGN =
IDENFR a
MULT *
IDENFR b
SEMICN ;
RBRACE }
ELSETK else
LBRACE {
IDENFR result
ASSIGN =
INTCON 0
SEMICN ;
RBRACE }
RBRACE }
ELSETK else
LBRACE {
IDENFR result
ASSIGN =
INTCON 0
SEMICN ;
RBRACE }
RETURNTK return
IDENFR result
SEMICN ;
RBRACE }
VOIDTK void
IDENFR process_array
LPARENT (
INTTK int
IDENFR arr
LBRACK [
RBRACK ]
RPARENT )
LBRACE {
INTTK int
IDENFR i
SEMICN ;
FORTK for
LPARENT (
IDENFR i
ASSIGN =
INTCON 0
SEMICN ;
IDENFR i
LSS <
INTCON 10
SEMICN ;
IDENFR i
ASSIGN =
IDENFR i
PLUS +
INTCON 1
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR arr
LBRACK [
IDENFR i
RBRACK ]
GRE >
INTCON 0
RPARENT )
LBRACE {
IDENFR arr
LBRACK [
IDENFR i
RBRACK ]
ASSIGN =
IDENFR arr
LBRACK [
IDENFR i
RBRACK ]
PLUS +
INTCON 1
SEMICN ;
RBRACE }
ELSETK else
LBRACE {
IDENFR arr
LBRACK [
IDENFR i
RBRACK ]
ASSIGN =
IDENFR arr
LBRACK [
IDENFR i
RBRACK ]
MINU -
INTCON 1
SEMICN ;
RBRACE }
RBRACE }
RBRACE }
INTTK int
MAINTK main
LPARENT (
RPARENT )
LBRACE {
INTTK int
IDENFR x
COMMA ,
IDENFR y
SEMICN ;
CHARTK char
IDENFR ch
SEMICN ;
IDENFR x
ASSIGN =
GETINTTK getint
LPARENT (
RPARENT )
SEMICN ;
IDENFR y
ASSIGN =
GETINTTK getint
LPARENT (
RPARENT )
SEMICN ;
INTTK int
IDENFR sum
ASSIGN =
IDENFR add
LPARENT (
IDENFR x
COMMA ,
IDENFR y
RPARENT )
SEMICN ;
INTTK int
IDENFR prod
ASSIGN =
IDENFR multiply
LPARENT (
IDENFR x
COMMA ,
IDENFR y
RPARENT )
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "Sum: %d\n"
COMMA ,
IDENFR sum
RPARENT )
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "Product: %d\n"
COMMA ,
IDENFR prod
RPARENT )
SEMICN ;
IDENFR process_array
LPARENT (
IDENFR arr
RPARENT )
SEMICN ;
INTTK int
IDENFR z
ASSIGN =
INTCON 0
SEMICN ;
IFTK if
LPARENT (
IDENFR sum
EQL ==
INTCON 0
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR prod
EQL ==
INTCON 0
RPARENT )
LBRACE {
IDENFR z
ASSIGN =
GETINTTK getint
LPARENT (
RPARENT )
SEMICN ;
IFTK if
LPARENT (
IDENFR z
EQL ==
INTCON 0
OR ||
IDENFR z
EQL ==
INTCON 1
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "Case 1\n"
RPARENT )
SEMICN ;
RBRACE }
ELSETK else
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "Case 2\n"
RPARENT )
SEMICN ;
RBRACE }
RBRACE }
ELSETK else
LBRACE {
IDENFR z
ASSIGN =
GETINTTK getint
LPARENT (
RPARENT )
SEMICN ;
IFTK if
LPARENT (
IDENFR z
EQL ==
INTCON 2
OR ||
IDENFR z
EQL ==
INTCON 3
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "Case 3\n"
RPARENT )
SEMICN ;
RBRACE }
ELSETK else
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "Case 4\n"
RPARENT )
SEMICN ;
RBRACE }
RBRACE }
RBRACE }
ELSETK else
LBRACE {
IDENFR z
ASSIGN =
GETINTTK getint
LPARENT (
RPARENT )
SEMICN ;
IFTK if
LPARENT (
IDENFR z
EQL ==
INTCON 4
OR ||
IDENFR z
EQL ==
INTCON 5
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "Case 5\n"
RPARENT )
SEMICN ;
RBRACE }
ELSETK else
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "Case 6\n"
RPARENT )
SEMICN ;
RBRACE }
RBRACE }
INTTK int
IDENFR i
SEMICN ;
FORTK for
LPARENT (
IDENFR i
ASSIGN =
INTCON 0
SEMICN ;
IDENFR i
LSS <
INTCON 5
SEMICN ;
IDENFR i
ASSIGN =
IDENFR i
PLUS +
INTCON 1
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR i
EQL ==
INTCON 0
RPARENT )
LBRACE {
IDENFR global_int
ASSIGN =
IDENFR add
LPARENT (
IDENFR global_int
COMMA ,
IDENFR i
RPARENT )
SEMICN ;
RBRACE }
ELSETK else
LBRACE {
IDENFR global_int
ASSIGN =
IDENFR multiply
LPARENT (
IDENFR global_int
COMMA ,
IDENFR i
RPARENT )
SEMICN ;
RBRACE }
RBRACE }
RETURNTK return
INTCON 0
SEMICN ;
RBRACE }
